_______________________________________________________________________
_____  __        __    __
  |   /  \  __  |  \  /  \
  |   \__/      |__/  \__/
_______________________________________________________________________
[OK]    importer le dump
[OK]    Supprimer le message history de l'utilisateur
[OK]     Regler le souci de duplicate key qui pop je sais pas trop quand
[NON]   explorer la db avec pgadmin
[ ]     Rediger des securites ?? un user qui n'est pas dans un channel
            ne peut pas y poster etc...
[ ] voir pour ajouter un bool isProtected pour savoir si y a un password
[ ] crypter le password dans la db et ne jamais l'envoyer dans le front
[ ] revoir l'accès aux channels protégés par des password (voir avec le header authorization)
→ actuellement tout le monde peut y avoir accès en allant au bon url !
[ ] enlever le champs password quand il n'y as pas de pasword
[ ] ajouter un 'show password'
[ ] owner of a channel can add/change/remove a password to access the channel
_______________________________________________________________________
QUESTIONS :
_______________________________________________________________________

- Amitiés a sens unique ? Demande puis acceptation ?
  >> resolu, c'est a sens unique comme sur stud42
- Comment gerer le ladder level ?
  >> en cours, j'ai donné des levels entre 10 (le plus bas) et 1 (le plus
  haut). Un seul user peut etre le niveau 1, les autres sont dans une pool.
  Si un joueur defie un joueur de niveau superieur et gagne, ils echangent
  leurs place. Problemes :
    * joueur de niveau 10 gagne vs niveau 1 : il passe direct niveau 1 ??
    * ou alors on les empeche de defier quelqu'un avec lequel ils ont plus
    d'un niveau d'ecart ??
- Est ce qu'on se sert de la date des messages ?

* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
* * * * * * * * * * * * * JOURNAL DE BORD * * * * * * * * * * * * * * * 
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

[3 decembre]
Fait en sorte que quand un utilisateur veux join un channel, qu'il soit
public ou privé, tout passe par une meme fonction qui :
- checke si le channel existe
- si oui, checke si le channel est protected
- si oui, envoie l'input de mdp dans le back pour verif
- si c'est ok -> join le channel
  si c'est non -> renvoie le message d'erreur approprié
+ Enlevé le champ de mot de passe pour les channels non protegés

[18 novembre]
J'ai pas mal fait de recherches sur les injections sql, pour l'instant
je vois pas de vulnerabilité mais en meme temps j'ai pas reussi a faire
d'injections nulle part... Vraisemblablement TypeORM nous protege pas mal
de ce genre de facéties.

[17 novembre]
Le dump comporte aussi des matches maintenant.
J'ai corrigé les fonctions de service qui utilisent matchId pour que ce
soit une string au lieu d'un number.

[10 novembre]
J'ai push sur master mes modifs de la veille, pas celles d'aujourd'hui.
Aujourd'hui j'ai fait du ménage :
    - J'ai supprimé messagesHistory du User parce qu'au final on s'en
sert pas du tout, du coup j'ai enlevé les références aux modules et
services inutiles.
    - J'ai un peu clean les imports.
    - J'ai enlevé currentMatch du User, il est commenté depuis un moment
et vu que Mederic a créé une entité Game je pense pas qu'on s'en servira
finalement.
    - J'ai renommé la variable ChannelDataService qui est dans le back
en ChannelService, comme ca ChannelDataService est uniquement presente
sur le front et les conventions de nommage sont respectées.

[9 novembre]
J'ai rajouté le user 'Illegal" avec id 0 dans le dump comme ca le illegal
login fonctionne toujours.
J'ai rajouté des DTO pour les match pour pouvoir faire des tests
Je me rends compte que j'ai un peu foiré mes getters etc parce que 
j'appelle pas toujours les fonctions des repositories avec await alors 
que la plupart de celles qu'on utilise sont async !! Je vais devoir tout
vérifier...
--> C'est fait, j'ai tout checké, les 200 occurrences !! ^^'
    sauf les trucs d'authentification (je prefere voir avec Servane demain)

Voila la liste exhaustive des methodes des repositories :
          manager   - The EntityManager used by this repository.
          metadata  - The EntityMetadata of the entity managed by this repository. Learn more about transactions in Entity Metadata.
          queryRunner - The query runner used by EntityManager. Used only in transactional instances of EntityManager.
          target    - The target entity class managed by this repository. Used only in transactional instances of EntityManager.
+   async createQueryBuilder - Creates a query builder use to build SQL queries. Learn more about QueryBuilder.
          hasId     - Checks if the given entity's primary column property is defined.
          getId     - Gets the primary column property values of the given entity. If entity has composite primary keys then the returned value will be an object with names and values of primary columns.
++        create    - Creates a new instance of User. Optionally accepts an object literal with user properties which will be written into newly created user object
          merge     - Merges multiple entities into a single entity.
++  async preload   - Creates a new entity from the given plain javascript object. If the entity already exists in the database, then it loads it (and everything related to it), replaces all values with the new ones from the given object, and returns the new entity. The new entity is actually an entity loaded from the database with all properties replaced from the new object.
++  async save      - Saves a given entity or array of entities. If the entity already exist in the database, it is updated. If the entity does not exist in the database, it is inserted. It saves all given entities in a single transaction (in the case of entity, manager is not transactional). Also supports partial updating since all undefined properties are skipped. Returns the saved entity/entities.
    async remove    - Removes a given entity or array of entities. It removes all given entities in a single transaction (in the case of entity, manager is not transactional). Returns the removed entity/entities.
    async insert    - Inserts a new entity, or array of entities.
++  async update    - Partially updates entity by a given update options or entity id.
    async upsert    - Inserts a new entity or array of entities unless they already exist in which case they are updated instead. Supported by AuroraDataApi, Cockroach, Mysql, Postgres, and Sqlite database drivers.
++  async delete    - Deletes entities by entity id, ids or given conditions:
    async softDelete and restore - Soft deleting and restoring a row by id
    async softRemove and recover - This is alternative to softDelete and restore.
    async count     - Counts entities that match given options. Useful for pagination.
    async increment - Increments some column by provided value of entities that match given options.
    async decrement - Decrements some column by provided value that match given options.
++  async find      - Finds entities that match given options.
    async findAndCount - Finds entities that match given find options. Also counts all entities that match given conditions, but ignores pagination settings (skip and take options).
    async findByIds - Finds multiple entities by id.
++  async findOne   - Finds first entity that matches some id or find options.
++  async findOneOrFail - Finds the first entity that matches the some id or find options. Rejects the returned promise if nothing matches.
    async query     - Executes a raw SQL query.
    async clear     - Clears all the data from the given table (truncates/drops it).

*********************************************************************

[8 novembre]
Putain ca a enfin marché !!! Du coup pas de yaml...

*********************************************************************

[2 novembre]
Je suis tres contente de ma refonte, ca marche nickel avec les IDs !!
En plus maintenant j'arrive bien a acceder a mes services et mes
repositories d'ou j'en ai besoin, et j'ai éliminé la dépendance circulaire.
J'ai ecrit beaucoup de setters/getters ces derniers jours, j'ai testé
ceux que je pouvais avec insomnia (ceux qui ont des dto en gros) du coup
je suis ready pour push sur master !!
>> A faire la prochaine fois :
- ecrire les fonctions de delete
- tester MATCH, ma derniere entités pas testée

*********************************************************************

[29 octobre]
Je suis arrivée au bout de ma demarche avec les relations de tables de
TypeORM, mais je me rend compte que c'est très fastidieux, surtout qu'a
priori il ne gere pas les arrays, et on en a beaucoup. Du coup, je pense
enlever toutes les relations de table pour pouvoir continuer a utiliser
les arrays, juste au lieu de stocker des references d'entités, je vais
stocker des IDs, ce sera beaucoup plus simple.
A faire demain donc.

*********************************************************************

[27 octobre]
L'importation du dump echoue toujours, enfin non l'importation se passe
officiellement bien d'apres les logs de compilation, mais je ne recupere
pas mes users, je sais pas pourquoi. Ptet que Servane a raison, que c'est
les images qui font chier dans la colle. Demain j'essaierai de recreer
le fichier de dump sans les images.
Sinon j'ai reussi a compiler les relations entre MATCH et USER, je m'attaque
maintenant au CHAT :
        |Module |Service    |Controller | Entity    | DTO
CHAT    |   OK  |  NO NEED  | NO NEED   | NO NEED   | NO NEED
CHANNEL |   OK  |   OK      |           |   OK      |  EUH...
MESSAGE |   OK  |   OK      |     OK    |   OK      |  EUH...

*********************************************************************

[25 octobre]
J'ai réussi a faire un dump !! (bon j'arrive pas a post d'autres users
depuis l'authentification donc il sert un peu a rien pour l'instant)
Voila la marche a suivre :
1) ouvrir un shell dans le container postgres
2) créer le fichier avec "pg_dump postgres -U admin > usersDB.sql"
(pas besoin d'etre dans la console postgres)
3) depuis un autre terminal, copier le fichier hors du container :
docker cp <containerID>:/usersDB.sql /host/path
4) (pas essayé encore) Importer le fichier avec la commande :
IMPORT usersDataBase.sql

Notes sur la console postgress :
Logging-in as admin :   psql -d postgres -U admin
Listing existing dbs :  \l || \list
Switching databases :   \c dbname || \connect dbname
Listing tables in db :  \dt

Useful docker command : docker system prune -a
-> This will remove:
  - all stopped containers
  - all networks not used by at least one container
  - all images without at least one container associated to them
  - all build cache

*********************************************************************

[22 octobre]
Useful Repository Methods :
- rep.getId(user) : returns PrimaryColumn info
- rep.create() || rep.create( { a: 1, b: 2} ) : creates a new User
- rep.merge(user, {b: 1}) : merges user properties
- rep.save(user) || rep.save([ cat1, cat2, cat3 ]) : saves the user in db
- remove
- insert
- update
- delete
- rep.count({a: 1}) : counts the user with value 1 as their A property
- rep.increment/decrement(User, {a: 1}, "b", 1) : increments or
decrements 1 to the value of the B property in users with value 1 as 
their A property
- find

*********************************************************************

[20 octobre]
J'ai ecrit toutes les propriétés auxquelles je pouvais penser dans les
entities USER, MATCH, MESSAGE et CHANNEL. Le seul truc qui manque c'est 
mettre les JoinColumn/Table() au bon endroit mais je dois encore y 
reflechir... De toute facon la DB ne compile pas si il y a des trous.
Si je veux faire des tests il faut que je mette {nullable: true} sur 
toutes mes propriétés.

*********************************************************************

[19 octobre]
Je commence a comprendre les relations entre entities sur TypeORM,
il me manque plus que ManyToMany a voir. J'ai ecrit une entity pour
les matches, il faudra que je la modifie selon ce que mederic a fait.
Sinon j'ai mis au propre ma vieille liste sur un draw.io.

*********************************************************************

[18 octobre]
Database structure :
USER entity :
    userName (string)
    intraId ()
    isOnline (bool)
    isInGame (bool)
    avatar (string)
    nbVictories (number)
    nbLosses (number)
    ladderLevel (number)
    achievements (string[])
    friends (number[] (avec intraId) ou string[] (avec userName))
    blackList (number[] (avec intraId) ou string[] (avec userName))
    matchHistory ()
MATCH entity :
    leftPlayer (string or number)
    rightPlayer (string or number)
    leftPlayerScore (number)
    rightPlayerScore (number)
    victor (string or number)
    leftBarPositionY (number)
    rightBarPositionY (number)
    ballPositionX (number)
    ballPositionY (number)
CHAT entity :
    ??? needed features : isOnline, blockUser, addFriend

*******************************************************

[14 octobre]
A mettre en script pour automatiser les dumps :
brew install postgresql
pg_dump postgres > usersDataBase.sql
IMPORT usersDataBase.sql
--> en fait ca marche pas les dumps, je change de technique
---> en fait SI, CA MARCHE, il suffisait juste de les faire
au bon endroit a savoir a l'interieur du container postgres
(cf. update du 25 octobre)

Using migrations instead :
npm i -g typeorm
typeorm migration:create
typeorm migration:run